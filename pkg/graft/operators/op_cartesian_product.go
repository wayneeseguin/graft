package operators

import (
	"fmt"

	"github.com/wayneeseguin/graft/internal/utils/ansi"
	"github.com/wayneeseguin/graft/internal/utils/tree"
)

// CartesianProductOperator ...
type CartesianProductOperator struct{}

// Setup ...
func (CartesianProductOperator) Setup() error {
	return nil
}

// Phase ...
func (CartesianProductOperator) Phase() OperatorPhase {
	return EvalPhase
}

// Dependencies ...
func (CartesianProductOperator) Dependencies(ev *Evaluator, args []*Expr, locs []*tree.Cursor, auto []*tree.Cursor) []*tree.Cursor {
	l := []*tree.Cursor{}

	for _, arg := range args {
		if arg.Type == Reference {
			for _, other := range locs {
				if other.Under(arg.Reference) {
					l = append(l, other)
				}
			}
		} else if arg.Type == OperatorCall {
			// Get dependencies from nested operator
			nestedOp := OperatorFor(arg.Op())
			if _, ok := nestedOp.(NullOperator); !ok {
				nestedDeps := nestedOp.Dependencies(ev, arg.Args(), locs, auto)
				l = append(l, nestedDeps...)
			}
		}
	}

	//append autogenerated dependencies (operator reference-type arguments)
	for _, dep := range auto {
		l = append(l, dep)
	}

	return l
}

// Run ...
func (CartesianProductOperator) Run(ev *Evaluator, args []*Expr) (*Response, error) {
	DEBUG("running (( cartesian-product ... )) operation at $.%s", ev.Here)
	defer DEBUG("done with (( cartesian-product ... )) operation at $%s\n", ev.Here)

	var vals [][]string

	for i, arg := range args {
		// Use ResolveOperatorArgument to support nested expressions
		val, err := ResolveOperatorArgument(ev, arg)
		if err != nil {
			DEBUG("     [%d]: resolution failed\n    error: %s", i, err)
			return nil, err
		}

		if val == nil {
			DEBUG("  arg[%d]: resolved to nil", i)
			return nil, fmt.Errorf("cartesian-product operator argument cannot be nil")
		}

		switch v := val.(type) {
		case string:
			DEBUG("  arg[%d]: found string value '%s'", i, v)
			vals = append(vals, []string{v})

		case int, int64, float64, bool:
			DEBUG("  arg[%d]: found scalar value '%v'", i, v)
			vals = append(vals, []string{fmt.Sprintf("%v", v)})

		case []interface{}:
			var strs []string

			DEBUG("  arg[%d]: resolved to a list; verifying", i)
			for j, sub := range v {
				if _, ok := sub.([]interface{}); ok {
					DEBUG("       list[%d]: list item is itself a list; error!", j)
					return nil, fmt.Errorf("cartesian-product operator can only operate on lists of scalar values")

				} else if _, ok := sub.(map[interface{}]interface{}); ok {
					DEBUG("       list[%d]: list item is a map; error!", j)
					return nil, fmt.Errorf("cartesian-product operator can only operate on lists of scalar values")

				}
				DEBUG("       list[%d]: list item is a scalar: %v", j, sub)
				strs = append(strs, fmt.Sprintf("%v", sub))
			}
			vals = append(vals, strs)

		case map[interface{}]interface{}, map[string]interface{}:
			DEBUG("     [%d]: resolved to a map; error!", i)
			return nil, fmt.Errorf("cartesian-product operator only accepts arrays and string values")

		default:
			DEBUG("     [%d]: resolved to a scalar; appending", i)
			vals = append(vals, []string{fmt.Sprintf("%v", val)})
		}
		DEBUG("")
	}

	switch len(args) {
	case 0:
		DEBUG("  no arguments supplied to (( cartesian-product ... )) operation.  oops.")
		return nil, ansi.Errorf("no arguments specified to @c{(( cartesian-product ... ))}")

	case 1:
		DEBUG("  called with only one argument; returning value as-is")
		return &Response{
			Type:  Replace,
			Value: vals[0],
		}, nil

	default:
		DEBUG("  called with more than one arguments; combining into a single list of strings")

		lst := []interface{}{}
		//Bootstrap the return list, making a list with interfaces, not strings
		for _, v := range vals[0] {
			lst = append(lst, v)
		}
		for _, l := range vals[1:] {
			lst = cartesian(lst, l)
		}

		return &Response{
			Type:  Replace,
			Value: lst,
		}, nil
	}
}

// input 'a' and the output are always a list of strings, but we need it to be
// a list of interfaces in the Go type system in order to be consistent with the
// way that the rest of graft handles yaml lists
func cartesian(a []interface{}, b []string) []interface{} {
	if len(a) == 0 || len(b) == 0 {
		return []interface{}{}
	}

	l := make([]interface{}, len(a)*len(b))
	n := 0
	for _, x := range a {
		for _, y := range b {
			l[n] = fmt.Sprintf("%s%s", x, y)
			n++
		}
	}

	return l
}

func init() {
	RegisterOp("cartesian-product", CartesianProductOperator{})
}
